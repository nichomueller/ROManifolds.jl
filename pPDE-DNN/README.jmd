FOM scheme

1) The folders are organized as follows:

- Mabla.jl/pPDE-DNN/ is the repository home;

- Mabla.jl/pPDE-DNN/code/ is where the src is located; Mabla.jl/pPDE-DNN/TESTS/ is where the FEM-ROM-DL results are stored, for every test;

- In Mabla.jl/pPDE-DNN/code we have 5 main folders: FEM, ROM, DL, TESTS and UTILS. In FEM/, ROM/ and DL/ the src for the (respectively) FEM, ROM and DL simulations is kept. For now, in each of the folders, we just have a ?.jl and a ?_utils.jl, where ? = fem, rb, dl. In the ?.jl we keep the functions that are called during the simulations, while in ?_utils.jl we keep auxiliary functions that are called in ?_utils.jl. In TESTS/ we have for each test case a config.jl file and a main.jl which respectively provide the user-defined configuration info of the problem, and the main that actually runs the simulation. There is a config_fem.jl, config_rb.jl and config_dl.jl, and the same for the mains. The mains import the correct configs automatically. Lastly, in UTILS/, we keep the .jl files that are not part of the previous folders; 

- The folder Mabla.jl/pPDE-DNN/TESTS/ basically has the same structure as Mabla.jl/pPDE-DNN/code/TESTS, but instead of the src this folder contains the simulation results. The only difference is that there is a directory Mabla.jl/pPDE-DNN/TESTS/MESHES/ where the computational meshes are stored.

2) Scheme of the FEM simulations (only Poisson problem for now)
 
- problem_specifics: struct collecting the information related to the desired FEM problem to be solved (e.g. problem type = steady/unsteady, ...) 
- param_info: struct collecting uniformly generated parameters, one (or more!) for every FEM snapshot  
- compute_parametric_info: struct collecting the following functions
0. model: the geometry employed during the simulation; if model = model(μᵒ), then the physical domain is μᵒ-dependent
1. α: an unknown quantity which multiplies the bilinear form a(∘,∘); if α = α(x), then a(∘,∘) is non-affine w.r.t. α;
2. f: the forcing term; if f = f(μᶠ), the right hand side is non-affine w.r.t the forcing term's contribution to the weak formulation;
3. h: the Neumann BC; if h = h(μʰ), the right hand side is non-affine w.r.t the Neumann BC's contribution to the weak formulation;
4. g: the Dirichlet BC; if g = g(μᵍ), a lifting operator is computed during the FEM simulation; in this way, the FEM trial space is not μᵍ-dependent.
- FE_specifics: struct collecting the problem's FE space information (e.g. V, V₀, ϕᵥ, ϕᵤ, ...) 
- assemble_stiffness, assemble_forcing, assemble_H1_norm_matrix: self explanatory; when a(∘,∘) and f(∘) are affine w.r.t. the problem's parameters, the quantities A and F are dumped to file
- output of the FEM simulations: high-fidelity snapshot matrix, which is the starting point of any ROM-DL algorithm

3) Scheme of the ROM simulations (only Poisson problem for now)

- ROM_specifics: struct collecting the information related to the desired ROM problem to be solved (e.g. RB_method = S-GRB, ST-GRB, ST-PGRB, ...) 
- RB_variables_struct: self explanatory; these variables are used within the ROM code multiple times, so it is convenient to keep them stored in a single struct. They are initialized via the initialize_RB_variables_struct() function;
- build_RB_approximation(...) performs the offline phase of the ROM 
- testing_phase(...) performs the online phase, for every new choice of parameters μᵒ, α, μᶠ, μʰ, μᵍ