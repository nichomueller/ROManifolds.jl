        - function ROM_paths(root, problem_type, problem_name, mesh_name, RB_method, case)
        0   paths = FEM_paths(root, problem_type, problem_name, mesh_name, case)
        0   mesh_path = paths.mesh_path
        0   FEM_snap_path = paths.FEM_snap_path
        0   FEM_structures_path = paths.FEM_structures_path
      144   ROM_path = joinpath(paths.current_test, RB_method)
      224   create_dir(ROM_path)
      160   basis_path = joinpath(ROM_path, "basis")
      224   create_dir(basis_path)
      160   ROM_structures_path = joinpath(ROM_path, "ROM_structures")
      224   create_dir(ROM_structures_path)
      160   gen_coords_path = joinpath(ROM_path, "gen_coords")
      224   create_dir(gen_coords_path)
      160   results_path = joinpath(ROM_path, "results")
      224   create_dir(results_path)
        0   _ -> (mesh_path, FEM_snap_path, FEM_structures_path, basis_path, ROM_structures_path, gen_coords_path, results_path)
        - end
        - 
        - function get_timesθ(RBInfo::Info) ::Vector
     2480   collect(RBInfo.t₀:RBInfo.δt:RBInfo.T-RBInfo.δt).+RBInfo.δt*RBInfo.θ
        - end
        - 
        - function build_sparse_mat(
        -   FEMInfo::ProblemInfoSteady,
        -   FEMSpace::SteadyProblem,
        -   Param::ParametricInfoSteady,
        -   el::Vector;
        -   var="A")
        - 
        -   Ω_sparse = view(FEMSpace.Ω, el)
        -   dΩ_sparse = Measure(Ω_sparse, 2 * FEMInfo.order)
        -   if var == "A"
        -     Mat = assemble_matrix(∫(∇(FEMSpace.ϕᵥ)⋅(Param.α*∇(FEMSpace.ϕᵤ)))*dΩ_sparse,
        -       FEMSpace.V, FEMSpace.V₀)
        -   else
        -     error("Unrecognized sparse matrix")
        -   end
        - 
        -   Mat
        - 
        - end
        - 
        - function build_sparse_mat(
        -   FEMInfo::ProblemInfoUnsteady,
        -   FEMSpace::UnsteadyProblem,
        -   Param::ParametricInfoUnsteady,
        -   el::Vector,
        -   timesθ::Vector;
        -   var="A")
        - 
      160   Ω_sparse = view(FEMSpace.Ω, el)
        0   dΩ_sparse = Measure(Ω_sparse, 2 * FEMInfo.order)
        0   Nₜ = length(timesθ)
        - 
      656   function define_Matₜ(t::Real, var::String)
        0     if var == "A"
    15024       return assemble_matrix(∫(∇(FEMSpace.ϕᵥ)⋅(Param.α(t)*∇(FEMSpace.ϕᵤ(t))))*dΩ_sparse,
        -         FEMSpace.V(t), FEMSpace.V₀)
        0     elseif mat == "M"
        0       return assemble_matrix(∫(FEMSpace.ϕᵥ*(Param.m(t)*FEMSpace.ϕᵤ(t)))*dΩ_sparse,
        -         FEMSpace.V(t), FEMSpace.V₀)
        -     else
        0       error("Unrecognized sparse matrix")
        -     end
        -   end
      528   Matₜ(t) = define_Matₜ(t, var)
        - 
        0   for (i_t,t) in enumerate(timesθ)
     2352     i,j,v = findnz(Matₜ(t))
        0     if i_t == 1
       48       global Mat = sparse(i,j,v,FEMSpace.Nₛᵘ,FEMSpace.Nₛᵘ*Nₜ)
        -     else
     5488       Mat[:,(i_t-1)*FEMSpace.Nₛᵘ+1:i_t*FEMSpace.Nₛᵘ] =
        -         sparse(i,j,v,FEMSpace.Nₛᵘ,FEMSpace.Nₛᵘ)
        -     end
        -   end
        - 
        0   Mat
        - 
        - end
        - 
        - function blocks_to_matrix(A_block::Array, N_blocks::Int)
        - 
        -   A = zeros(prod(size(A_block[1])), N_blocks)
        -   for n = 1:N_blocks
        -     A[:, n] = A_block[n][:]
        -   end
        - 
        -   A
        - 
        - end
        - 
        - function matrix_to_blocks(A::Array)
        - 
        -   A_block = Matrix{Float64}[]
        -   N_blocks = size(A)[end]
        -   dims = Tuple(size(A)[1:end-1])
        -   order = prod(size(A)[1:end-1])
        -   for n = 1:N_blocks
        -     push!(A_block, reshape(A[:][(n-1)*order+1:n*order], dims))
        -   end
        - 
        -   A_block
        - 
        - end
        - 
        - function remove_small_entries(A::Array,tol=1e-15) ::Array
        -   A[A.<=tol].=0
        -   A
        - end
        - 
        - function compute_errors(uₕ::Matrix, RBVars::RBSteadyProblem, norm_matrix = nothing)
        - 
        -   mynorm(uₕ - RBVars.ũ, norm_matrix) / mynorm(uₕ, norm_matrix)
        - 
        - end
        - 
        - function compute_errors(uₕ::Matrix, RBVars::RBUnsteadyProblem, norm_matrix = nothing)
        - 
      496   H1_err = zeros(RBVars.Nₜ)
      496   H1_sol = zeros(RBVars.Nₜ)
        - 
        0   for i = 1:RBVars.Nₜ
  2751904     H1_err[i] = mynorm(uₕ[:, i] - RBVars.S.ũ[:, i], norm_matrix)
  5496000     H1_sol[i] = mynorm(uₕ[:, i], norm_matrix)
        -   end
        - 
      496   return H1_err ./ H1_sol, norm(H1_err) / norm(H1_sol)
        - 
        - end
        - 
        - function compute_MDEIM_error(FEMSpace::FEMProblem, RBInfo::Info, RBVars::RBProblem)
        - 
        -   Aₙ_μ = (RBVars.Φₛᵘ)' * assemble_stiffness(FEMSpace, RBInfo, Param) * RBVars.Φₛᵘ
        - 
        - end
        - 
        - function post_process()
        -   paths = FEM_paths(root, problem_type, problem_name, mesh_name, case)
        -   root = paths.current_test
        -   root_subs = get_all_subdirectories(root)
        -   filter!(el->!occursin("FEM_data",el),root_subs)
        - 
        -   (ϵ,ϵ_fun,ϵ_sampl,ϵ_fun_sampl,ϵ_nest,ϵ_fun_nest,ϵ_sampl_nest,ϵ_fun_sampl_nest) =
        -     (String[],String[],String[],String[],String[],String[],String[],String[])
        -   t,errH1L2 = Float64[],Float64[]
        -   t_sampl,errH1L2_sampl = Float64[],Float64[]
        -   t_fun,errH1L2_fun = Float64[],Float64[]
        -   t_fun_sampl,errH1L2_fun_sampl = Float64[],Float64[]
        -   t_nest,errH1L2_nest = Float64[],Float64[]
        -   t_sampl_nest,errH1L2_sampl_nest = Float64[],Float64[]
        -   t_fun_nest,errH1L2_fun_nest = Float64[],Float64[]
        -   t_fun_sampl_nest,errH1L2_fun_sampl_nest = Float64[],Float64[]
        - 
        -   for dir in root_subs
        -     if !occursin("nest",dir)
        -       if !occursin("sampl",dir)
        -         ϵ,ϵ_fun,errH1L2,errH1L2_fun,t,t_fun =
        -           check_if_fun(dir,ϵ,ϵ_fun,errH1L2,errH1L2_fun,t,t_fun)
        -       else
        -         ϵ_sampl,ϵ_fun_sampl,errH1L2_sampl,errH1L2_fun_sampl,t_sampl,t_fun_sampl =
        -           check_if_fun(dir,ϵ_sampl,ϵ_fun_sampl,errH1L2_sampl,errH1L2_fun_sampl,
        -           t_sampl,t_fun_sampl)
        -       end
        -     else
        -       if !occursin("sampl",dir)
        -         ϵ_nest,ϵ_fun_nest,errH1L2_nest,errH1L2_fun_nest,t_nest,t_fun_nest =
        -           check_if_fun(dir,ϵ_nest,ϵ_fun_nest,errH1L2_nest,errH1L2_fun_nest,
        -           t_nest,t_fun_nest)
        -       else
        -         ϵ_sampl_nest,ϵ_fun_sampl_nest,errH1L2_sampl_nest,errH1L2_fun_sampl_nest,
        -           t_sampl_nest,t_fun_sampl_nest = check_if_fun(dir,ϵ_sampl_nest,
        -           ϵ_fun_sampl_nest,errH1L2_sampl_nest,errH1L2_fun_sampl_nest,
        -           t_sampl_nest,t_fun_sampl_nest)
        -       end
        -     end
        -   end
        - 
        -   errors = Dict("Standard"=>errH1L2,"Functional"=>errH1L2_fun,
        -   "Standard-sampling"=>errH1L2_sampl,"Functional-sampling"=>errH1L2_fun_sampl,
        -   "Standard-nested"=>errH1L2_nest,"Functional-nested"=>errH1L2_fun_nest,
        -   "Standard-sampling-nested"=>errH1L2_sampl_nest,
        -   "Functional-sampling-nested"=>errH1L2_fun_sampl_nest)
        -   times = Dict("Standard"=>t,"Functional"=>t_fun,
        -   "Standard-sampling"=>t_sampl,"Functional-sampling"=>t_fun_sampl,
        -   "Standard-nested"=>t_nest,"Functional-nested"=>t_fun_nest,
        -   "Standard-sampling-nested"=>t_sampl_nest,
        -   "Functional-sampling-nested"=>t_fun_sampl_nest)
        -   tols = Dict("Standard"=>ϵ,"Functional"=>ϵ_fun,
        -   "Standard-sampling"=>ϵ_sampl,"Functional-sampling"=>ϵ_fun_sampl,
        -   "Standard-nested"=>ϵ_nest,"Functional-nested"=>ϵ_fun_nest,
        -   "Standard-sampling-nested"=>ϵ_sampl_nest,
        -   "Functional-sampling-nested"=>ϵ_fun_sampl_nest)
        - 
        -   plots_dir = joinpath(root,"plots")
        -   create_dir(plots_dir)
        - 
        -   for (key, val) in errors
        -     ϵ = parse.(Float64,tols[key])
        -     xvals = hcat(ϵ,ϵ)'
        -     yvals = hcat(val,ϵ)'
        -     labels = hcat(["H¹-l² err"],["ϵ"])'
        -     generate_and_save_plot(xvals,yvals,"Average H¹-l² err, method: "*key,
        -     ["H¹-l² err","ϵ"],"ϵ","",plots_dir,true,true;var="err_"*key,
        -     modes=vcat(["lines"],["lines"]))
        -   end
        -   for (key, val) in times
        -     generate_and_save_plot(val,"Average online time, method: "*key,tols[key],
        -     "","",plots_dir,false,true;var="time_"*key,modes=["scatter"])
        -   end
        - 
        -   function get_paths(dir::String)::Tuple
        -     path_to_err = joinpath(dir,
        -       "results/Params_95_96_97_98_99_100/H1L2_err.csv")
        -     path_to_t = joinpath(dir,
        -       "results/Params_95_96_97_98_99_100/times.csv")
        -     path_to_err,path_to_t
        -   end
        - 
        -   function get_tolerances(dir::String)::Vector
        -     if occursin("-3",dir)
        -       return ["1e-3"]
        -     elseif occursin("-4",dir)
        -       return ["1e-4"]
        -     elseif occursin("-5",dir)
        -       return ["1e-5"]
        -     else
        -       error("Unrecognized tolerance")
        -     end
        -   end
        - 
        -   function check_if_fun(dir::String,tol,tol_fun,err,err_fun,time,time_fun)
        -     path_to_err,path_to_t = get_paths(dir)
        -     if ispath(path_to_err) && ispath(path_to_t)
        -       if occursin("fun",dir)
        -         append!(tol_fun,get_tolerances(dir))
        -         append!(err_fun,load_CSV(path_to_err)[1])
        -         append!(time_fun,load_CSV(path_to_t)[1,1])
        -       else
        -         append!(tol,get_tolerances(dir))
        -         append!(err,load_CSV(path_to_err)[1])
        -         append!(time,load_CSV(path_to_t)[1,1])
        -       end
        -     end
        -     return tol,tol_fun,err,err_fun,time,time_fun
        -   end
        - 
        - end
