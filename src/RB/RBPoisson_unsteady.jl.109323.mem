        - include("RBPoisson_steady.jl")
        - include("ST-GRB_Poisson.jl")
        - include("ST-PGRB_Poisson.jl")
        - 
        - function get_snapshot_matrix(RBInfo::Info, RBVars::PoissonUnsteady)
        - 
        0   if RBInfo.perform_nested_POD
        0     @info "Importing the snapshot matrix for field u obtained
        -       with the nested POD"
        0     Sᵘ = Matrix(CSV.read(joinpath(RBInfo.paths.FEM_snap_path, "uₕ.csv"),
        -       DataFrame))
        -   else
    66320     @info "Importing the snapshot matrix for field u,
        -       number of snapshots considered: $(RBInfo.nₛ)"
      192     Sᵘ = Matrix(CSV.read(joinpath(RBInfo.paths.FEM_snap_path, "uₕ.csv"),
        -       DataFrame))[:, 1:(RBInfo.nₛ*RBVars.Nₜ)]
        -   end
        - 
        0   RBVars.S.Sᵘ = Sᵘ
        0   Nₛᵘ = size(Sᵘ)[1]
        0   RBVars.S.Nₛᵘ = Nₛᵘ
        0   RBVars.Nᵘ = RBVars.S.Nₛᵘ * RBVars.Nₜ
        - 
      416   @info "Dimension of the snapshot matrix for field u: $(size(Sᵘ))"
        - 
        - end
        - 
        - PODs_space(RBInfo::Info, RBVars::PoissonUnsteady) = PODs_space(RBInfo, RBVars.S)
        - 
        - function PODs_time(RBInfo::Info, RBVars::PoissonUnsteady)
        - 
     3424   @info "Performing the temporal POD for field u, using a tolerance of $(RBInfo.ϵₜ)"
        - 
        0   if RBInfo.time_reduction_technique == "ST-HOSVD"
  2816048     Sᵘₜ = zeros(RBVars.Nₜ, RBVars.S.nₛᵘ * RBInfo.nₛ)
       16     Sᵘ = RBVars.S.Φₛᵘ' * RBVars.S.Sᵘ
        0     for i in 1:RBInfo.nₛ
    12752       Sᵘₜ[:, (i-1)*RBVars.S.nₛᵘ+1:i*RBVars.S.nₛᵘ] =
        -       Sᵘ[:, (i-1)*RBVars.Nₜ+1:i*RBVars.Nₜ]'
        -     end
        -   else
        0     Sᵘₜ = zeros(RBVars.Nₜ, RBVars.S.Nₛᵘ * RBInfo.nₛ)
        0     Sᵘ = RBVars.S.Sᵘ
        0     for i in 1:RBInfo.nₛ
        0       Sᵘₜ[:, (i-1)*RBVars.S.Nₛᵘ+1:i*RBVars.S.Nₛᵘ] =
        -       transpose(Sᵘ[:, (i-1)*RBVars.Nₜ+1:i*RBVars.Nₜ])
        -     end
        -   end
        - 
        0   Φₜᵘ, _ = POD(Sᵘₜ, RBInfo.ϵₜ)
        0   RBVars.Φₜᵘ = Φₜᵘ
        0   RBVars.nₜᵘ = size(Φₜᵘ)[2]
        - 
        - end
        - 
        - function build_reduced_basis(RBInfo::Info, RBVars::PoissonUnsteady)
        - 
     2720   @info "Building the space-time reduced basis for field u"
        - 
        0   RB_building_time = @elapsed begin
        -     PODs_space(RBInfo, RBVars)
        -     PODs_time(RBInfo, RBVars)
        -   end
        - 
        0   RBVars.nᵘ = RBVars.S.nₛᵘ * RBVars.nₜᵘ
        0   RBVars.Nᵘ = RBVars.S.Nₛᵘ * RBVars.Nₜ
        - 
        0   RBVars.S.offline_time += RB_building_time
        - 
        0   if RBInfo.save_offline_structures
      192     save_CSV(RBVars.S.Φₛᵘ, joinpath(RBInfo.paths.basis_path, "Φₛᵘ.csv"))
      192     save_CSV(RBVars.Φₜᵘ, joinpath(RBInfo.paths.basis_path, "Φₜᵘ.csv"))
        -   end
        - 
        - end
        - 
        - function import_reduced_basis(RBInfo::Info, RBVars::PoissonUnsteady)
        - 
        0   import_reduced_basis(RBInfo, RBVars.S)
        - 
        0   @info "Importing the temporal reduced basis for field u"
        0   RBVars.Φₜᵘ = load_CSV(joinpath(RBInfo.paths.basis_path, "Φₜᵘ.csv"))
        0   RBVars.nₜᵘ = size(RBVars.Φₜᵘ)[2]
        0   RBVars.nᵘ = RBVars.S.nₛᵘ * RBVars.nₜᵘ
        - 
        - end
        - 
        - function index_mapping(i::Int,j::Int,RBVars::PoissonUnsteady) ::Int
        -   Int((i-1)*RBVars.nₜᵘ+j)
        - end
        - 
        - function index_mapping_inverse(i::Int,RBVars::PoissonUnsteady) ::Tuple
        -   iₛ = 1+floor(Int64,(i-1)/RBVars.nₜᵘ)
        -   iₜ = i-(iₛ-1)*RBVars.nₜᵘ
        -   iₛ,iₜ
        - end
        - 
        - function get_generalized_coordinates(RBInfo::Info, RBVars::PoissonUnsteady, snaps=nothing)
        - 
        -   if check_norm_matrix(RBVars.S)
        -     get_norm_matrix(RBInfo, RBVars.S)
        -   end
        - 
        -   if isnothing(snaps) || maximum(snaps) > RBInfo.nₛ
        -     snaps = 1:RBInfo.nₛ
        -   end
        - 
        -   û = zeros(RBVars.nᵘ, length(snaps))
        -   Φₛᵘ_normed = RBVars.S.Xᵘ₀ * RBVars.S.Φₛᵘ
        - 
        -   for (i, i_nₛ) = enumerate(snaps)
        -     @info "Assembling generalized coordinate relative to snapshot $(i_nₛ), field u"
        -     S_i = RBVars.S.Sᵘ[:, (i_nₛ-1)*RBVars.Nₜ+1:i_nₛ*RBVars.Nₜ]
        -     for i_s = 1:RBVars.S.nₛᵘ
        -       for i_t = 1:RBVars.nₜᵘ
        -         Π_ij = reshape(Φₛᵘ_normed[:,i_s],:,1).*reshape(RBVars.Φₜᵘ[:,i_t],:,1)'
        -         û[index_mapping(i_s, i_t, RBVars), i] = sum(Π_ij .* S_i)
        -       end
        -     end
        -   end
        - 
        -   RBVars.S.û = û
        - 
        -   if RBInfo.save_offline_structures
        -     save_CSV(û, joinpath(RBInfo.paths.gen_coords_path, "û.csv"))
        -   end
        - 
        - end
        - 
        - function test_offline_phase(RBInfo::Info, RBVars::PoissonUnsteady)
        - 
        -   get_generalized_coordinates(RBInfo, RBVars, 1)
        - 
        -   uₙ = reshape(RBVars.S.û, (RBVars.nₜᵘ, RBVars.S.nₛᵘ))
        -   u_rec = RBVars.S.Φₛᵘ * (RBVars.Φₜᵘ * uₙ)'
        -   err = zeros(RBVars.Nₜ)
        -   for i = 1:RBVars.Nₜ
        -     err[i] = compute_errors(RBVars.S.Sᵘ[:, i], u_rec[:, i])
        -   end
        - 
        - end
        - 
        - function assemble_MDEIM_matrices(
        -   RBInfo::Info,
        -   RBVars::PoissonUnsteady,
        -   var::String)
        - 
        0   if var == "M"
        0     @info "The matrix $var is non-affine:
        -       running the MDEIM offline phase on $(RBInfo.nₛ_MDEIM) snapshots"
        0     if isempty(RBVars.MDEIM_mat_M)
        0       (RBVars.MDEIM_mat_M, RBVars.MDEIM_idx_M, RBVars.MDEIMᵢ_M, RBVars.row_idx_M,
        -         RBVars.sparse_el_M) = MDEIM_offline(FEMSpace, RBInfo, "M")
        -     end
        0     assemble_reduced_mat_MDEIM(
        -       RBInfo,RBVars,RBVars.MDEIM_mat_M,RBVars.row_idx_M,"M")
        0   elseif var == "A"
        0     if isempty(RBVars.S.MDEIM_mat_A)
      160       (RBVars.S.MDEIM_mat_A, RBVars.S.MDEIM_idx_A, RBVars.S.MDEIMᵢ_A,
        -       RBVars.S.row_idx_A,RBVars.S.sparse_el_A) = MDEIM_offline(FEMSpace, RBInfo, "A")
        -     end
      160     assemble_reduced_mat_MDEIM(
        -       RBInfo,RBVars,RBVars.S.MDEIM_mat_A,RBVars.S.row_idx_A,"A")
        -   else
        0     error("Unrecognized variable on which to perform MDEIM")
        -   end
        - 
        - end
        - 
        - function assemble_DEIM_vectors(
        -   RBInfo::Info,
        -   RBVars::PoissonUnsteady,
        -   var::String)
        - 
      512   @info "The vector $var is non-affine:
        -     running the DEIM offline phase on $(RBInfo.nₛ_MDEIM) snapshots"
        - 
        0   if var == "F"
        0     if isempty(RBVars.S.DEIM_mat_F)
      160        RBVars.S.DEIM_mat_F, RBVars.S.DEIM_idx_F, RBVars.S.DEIMᵢ_F =
        -         DEIM_offline(FEMSpace,RBInfo,"F")
        -     end
      160     assemble_reduced_mat_DEIM(RBInfo,RBVars,RBVars.S.DEIM_mat_F,"F")
        0   elseif var == "H"
        0     if isempty(RBVars.S.DEIM_mat_H)
        0        RBVars.S.DEIM_mat_H, RBVars.S.DEIM_idx_H, RBVars.S.DEIMᵢ_H =
        -         DEIM_offline(FEMSpace,RBInfo,"H")
        -     end
        0     assemble_reduced_mat_DEIM(RBInfo,RBVars, RBVars.S.DEIM_mat_H,"H")
        -   else
        0     error("Unrecognized variable on which to perform DEIM")
        -   end
        - 
        - end
        - 
        - function save_M_DEIM_structures(RBInfo::Info, RBVars::PoissonUnsteady)
        - 
      192   list_M_DEIM = (RBVars.MDEIM_mat_M, RBVars.MDEIMᵢ_M, RBVars.MDEIM_idx_M,
        -     RBVars.sparse_el_M, RBVars.row_idx_M)
        0   list_names = ("MDEIM_mat_M", "MDEIMᵢ_M", "MDEIM_idx_M", "sparse_el_M",
        -    "row_idx_M")
      144   l_info_vec = [[l_idx,l_val] for (l_idx,l_val) in
        -     enumerate(list_M_DEIM) if !all(isempty.(l_val))]
        - 
        0   if !isempty(l_info_vec)
        0     l_info_mat = reduce(vcat,transpose.(l_info_vec))
        0     l_idx,l_val = l_info_mat[:,1], transpose.(l_info_mat[:,2])
        0     for (i₁,i₂) in enumerate(l_idx)
        0       save_CSV(l_val[i₁], joinpath(RBInfo.paths.ROM_structures_path,
        -         list_names[i₂]*".csv"))
        -     end
        -   end
        - 
        0   save_M_DEIM_structures(RBInfo, RBVars.S)
        - 
        - end
        - 
        - function set_operators(RBInfo, RBVars::PoissonUnsteady) :: Vector
        - 
        -   return vcat(["M"], set_operators(RBInfo, RBVars.S))
        - 
        - end
        - 
        - function get_M_DEIM_structures(RBInfo::Info, RBVars::PoissonUnsteady) :: Vector
        - 
        0   operators = String[]
        - 
        0   if RBInfo.probl_nl["M"]
        - 
        0     if isfile(joinpath(RBInfo.paths.ROM_structures_path, "MDEIMᵢ_M.csv"))
        0       @info "Importing MDEIM offline structures for the mass matrix"
        0       RBVars.MDEIMᵢ_M = load_CSV(joinpath(RBInfo.paths.ROM_structures_path,
        -         "MDEIMᵢ_M.csv"))
        0       RBVars.MDEIM_idx_M = load_CSV(joinpath(RBInfo.paths.ROM_structures_path,
        -         "MDEIM_idx_M.csv"))[:]
        0       RBVars.sparse_el_M = load_CSV(joinpath(RBInfo.paths.ROM_structures_path,
        -         "sparse_el_M.csv"))[:]
        0       RBVars.row_idx_M = load_CSV(joinpath(RBInfo.paths.ROM_structures_path,
        -         "row_idx_M.csv"))[:]
        0       append!(operators, [])
        -     else
        0       @info "Failed to import MDEIM offline structures for the mass matrix: must build them"
        0       append!(operators, ["M"])
        -     end
        - 
        -   end
        - 
        0   append!(operators, get_M_DEIM_structures(RBInfo, RBVars.S))
        - 
        - end
        - 
        - function get_offline_structures(RBInfo::Info, RBVars::PoissonUnsteady) ::Vector
        - 
        0   operators = String[]
        0   append!(operators, get_affine_structures(RBInfo, RBVars))
        0   append!(operators, get_M_DEIM_structures(RBInfo, RBVars))
        0   unique!(operators)
        - 
        0   operators
        - 
        - end
        - 
        - function get_θᵐ(RBInfo::Info, RBVars::RBUnsteadyProblem, Param::ParametricInfoUnsteady) ::Array
        0   timesθ = get_timesθ(RBInfo)
        0   if !RBInfo.probl_nl["M"]
        0     θᵐ = [Param.mₜ(t_θ) for t_θ = timesθ]
        -   else
        0     M_μ_sparse = build_sparse_mat(
        -       FEMInfo,FEMSpace,Param,RBVars.S.sparse_el_A,timesθ;var="M")
        0     Nₛᵘ = RBVars.S.Nₛᵘ
        0     θᵐ = zeros(RBVars.Qᵐ, RBVars.Nₜ)
        0     for iₜ = 1:RBVars.Nₜ
        0       θᵐ[:,iₜ] = M_DEIM_online(M_μ_sparse[:,(iₜ-1)*Nₛᵘ+1:iₜ*Nₛᵘ],
        -         RBVars.MDEIMᵢ_M, RBVars.MDEIM_idx_M)
        -     end
        -   end
        - 
        0   θᵐ = reshape(θᵐ, RBVars.Qᵐ, RBVars.Nₜ)
        - 
        0   return θᵐ
        - 
        - end
        - 
        - function get_θᵐₛₜ(RBInfo::Info, RBVars::RBUnsteadyProblem, Param::ParametricInfoUnsteady) ::Array
        - 
        0   if !RBInfo.probl_nl["M"]
        0     θᵐ = [1]
        -   else
        0     timesθ_mod,MDEIM_idx_mod =
        -       modify_timesθ_and_MDEIM_idx(RBVars.MDEIM_idx_M,RBInfo,RBVars)
        0     M_μ_sparse = build_sparse_mat(FEMInfo, FEMSpace, Param,
        -       RBVars.sparse_el_M, timesθ_mod; var="M")
        0     θᵐ = RBVars.MDEIMᵢ_M\Vector(M_μ_sparse[MDEIM_idx_mod])
        -   end
        - 
        0   return θᵐ
        - 
        - end
        - 
        - function get_θᵃ(RBInfo::Info, RBVars::RBUnsteadyProblem, Param::ParametricInfoUnsteady) ::Array
        - 
        0   timesθ = get_timesθ(RBInfo)
        0   if !RBInfo.probl_nl["A"]
        0     θᵃ = [Param.αₜ(t_θ,Param.μ) for t_θ = timesθ]
        -   else
       16     A_μ_sparse = build_sparse_mat(
        -       FEMInfo,FEMSpace,Param,RBVars.S.sparse_el_A,timesθ;var="A")
        0     Nₛᵘ = RBVars.S.Nₛᵘ
    10944     θᵃ = zeros(RBVars.S.Qᵃ, RBVars.Nₜ)
        0     for iₜ = 1:RBVars.Nₜ
     4784       θᵃ[:,iₜ] = M_DEIM_online(A_μ_sparse[:,(iₜ-1)*Nₛᵘ+1:iₜ*Nₛᵘ],
        -         RBVars.S.MDEIMᵢ_A, RBVars.S.MDEIM_idx_A)
        -     end
        -   end
        - 
        0   θᵃ = reshape(θᵃ, RBVars.S.Qᵃ, RBVars.Nₜ)
        - 
        0   return θᵃ
        - 
        - end
        - 
        - function get_θᵃₛₜ(RBInfo::Info, RBVars::RBUnsteadyProblem, Param::ParametricInfoUnsteady) ::Array
        - 
        0   if !RBInfo.probl_nl["A"]
        0     θᵃ = [1]
        -   else
        0     timesθ_mod,MDEIM_idx_mod =
        -       modify_timesθ_and_MDEIM_idx(RBVars.S.MDEIM_idx_A,RBInfo,RBVars)
        0     A_μ_sparse = build_sparse_mat(FEMInfo, FEMSpace, Param,
        -       RBVars.S.sparse_el_A, timesθ_mod; var="A")
        0     θᵃ = RBVars.S.MDEIMᵢ_A\Vector(A_μ_sparse[MDEIM_idx_mod])
        -   end
        - 
        0   return θᵃ
        - 
        - end
        - 
        - function get_θᶠʰ(RBInfo::Info, RBVars::RBUnsteadyProblem, Param::ParametricInfoUnsteady) ::Tuple
        - 
        0   if RBInfo.build_Parametric_RHS
        0     error("Cannot fetch θᶠ, θʰ if the RHS is built online")
        -   end
        - 
        0   timesθ = get_timesθ(RBInfo)
      128   θᶠ, θʰ = Float64[], Float64[]
        - 
        0   if !RBInfo.probl_nl["f"]
        0     θᶠ = [Param.fₜ(t_θ) for t_θ = timesθ]
        -   else
      256     F_μ = assemble_forcing(FEMSpace, RBInfo, Param)
        0     for iₜ = 1:RBVars.Nₜ
        0       append!(θᶠ,
        -         M_DEIM_online(F_μ(timesθ[iₜ]), RBVars.S.DEIMᵢ_F, RBVars.S.DEIM_idx_F))
        -     end
        -   end
        - 
        0   if !RBInfo.probl_nl["h"]
        0     θʰ = [Param.hₜ(t_θ) for t_θ = timesθ]
        -   else
        0     H_μ = assemble_neumann_datum(FEMSpace, RBInfo, Param)
        0     for iₜ = 1:RBVars.Nₜ
        0       append!(θʰ,
        -         M_DEIM_online(H_μ(timesθ[iₜ]), RBVars.S.DEIMᵢ_H, RBVars.S.DEIM_idx_H))
        -     end
        -   end
        - 
        0   θᶠ = reshape(θᶠ, RBVars.S.Qᶠ, RBVars.Nₜ)
        0   θʰ = reshape(θʰ, RBVars.S.Qʰ, RBVars.Nₜ)
        - 
      144   return θᶠ, θʰ
        - 
        - end
        - 
        - function get_θᶠʰₛₜ(RBInfo::Info, RBVars::RBUnsteadyProblem, Param::ParametricInfoUnsteady) ::Tuple
        - 
        0   if RBInfo.build_Parametric_RHS
        0     error("Cannot fetch θᶠ, θʰ if the RHS is built online")
        -   end
        - 
        0   if !RBInfo.probl_nl["f"]
        0     θᶠ = [1]
        -   else
        0     F_μ = assemble_forcing(FEMSpace, RBInfo, Param)
        0     _,DEIM_idx_mod = modify_timesθ_and_MDEIM_idx(RBVars.S.DEIM_idx_F,RBInfo,RBVars)
        0     θᶠ = RBVars.S.DEIMᵢ_F\Vector(F_μ[DEIM_idx_mod])
        -   end
        - 
        0   if !RBInfo.probl_nl["h"]
        0     θʰ = [1]
        -   else
        0     H_μ = assemble_neumann_datum(FEMSpace, RBInfo, Param)
        0     _,DEIM_idx_mod = modify_timesθ_and_MDEIM_idx(RBVars.S.DEIM_idx_H,RBInfo,RBVars)
        0     θʰ = RBVars.S.DEIMᵢ_H\Vector(H_μ[DEIM_idx_mod])
        -   end
        - 
        0   return θᶠ, θʰ
        - 
        - end
        - 
        - function solve_RB_system(RBInfo::Info, RBVars::PoissonUnsteady, Param::ParametricInfoUnsteady)
        0   get_RB_system(RBInfo, RBVars, Param)
     2720   @info "Solving RB problem via backslash"
     2752   @info "Condition number of the system's matrix: $(cond(RBVars.S.LHSₙ[1]))"
    14208   RBVars.S.online_time += @elapsed begin
        -     RBVars.S.uₙ = zeros(RBVars.nᵘ)
        -     RBVars.S.uₙ = RBVars.S.LHSₙ[1] \ RBVars.S.RHSₙ[1]
        -   end
        - end
        - 
        - function reconstruct_FEM_solution(RBVars::PoissonUnsteady)
     2720   @info "Reconstructing FEM solution from the newly computed RB one"
        0   uₙ = reshape(RBVars.S.uₙ, (RBVars.nₜᵘ, RBVars.S.nₛᵘ))
       16   RBVars.S.ũ = RBVars.S.Φₛᵘ * (RBVars.Φₜᵘ * uₙ)'
        - end
        - 
        - function offline_phase(RBInfo::Info, RBVars::PoissonUnsteady)
        - 
        0   RBVars.Nₜ = convert(Int64, RBInfo.T / RBInfo.δt)
        - 
        0   if RBInfo.import_snapshots
        0     get_snapshot_matrix(RBInfo, RBVars)
        -     import_snapshots_success = true
        -   else
        -     import_snapshots_success = false
        -   end
        - 
        0   if RBInfo.import_offline_structures
        0     import_reduced_basis(RBInfo, RBVars)
        -     import_basis_success = true
        -   else
        -     import_basis_success = false
        -   end
        - 
        0   if !import_snapshots_success && !import_basis_success
        0     error("Impossible to assemble the reduced problem if neither
        -       the snapshots nor the bases can be loaded")
        -   end
        - 
        0   if import_snapshots_success && !import_basis_success
     2720     @info "Failed to import the reduced basis, building it via POD"
        0     build_reduced_basis(RBInfo, RBVars)
        -   end
        - 
        0   if RBInfo.import_offline_structures
        0     operators = get_offline_structures(RBInfo, RBVars)
        0     if !isempty(operators)
        0       assemble_offline_structures(RBInfo, RBVars, operators)
        -     end
        -   else
        0     assemble_offline_structures(RBInfo, RBVars)
        -   end
        - 
        - end
        - 
        - function loop_on_params(
        -   RBInfo::Info,
        -   RBVars::PoissonUnsteady,
        -   μ::Matrix,
        -   param_nbs) ::Tuple
        - 
       64   H1_L2_err = zeros(length(param_nbs))
      496   mean_H1_err = zeros(RBVars.Nₜ)
        -   mean_H1_L2_err = 0.0
  2743664   mean_pointwise_err = zeros(RBVars.S.Nₛᵘ, RBVars.Nₜ)
        -   mean_online_time = 0.0
        -   mean_reconstruction_time = 0.0
        - 
  2743664   ũ_μ = zeros(RBVars.S.Nₛᵘ, length(param_nbs)*RBVars.Nₜ)
    14208   uₙ_μ = zeros(RBVars.nᵘ, length(param_nbs))
        - 
        0   for (i_nb, nb) in enumerate(param_nbs)
      144     println("\n")
     3120     @info "Considering Parameter number: $nb/$(param_nbs[end])"
        - 
      368     μ_nb = parse.(Float64, split(chop(μ[nb]; head=1, tail=1), ','))
        0     Param = get_ParamInfo(problem_ntuple, RBInfo, μ_nb)
        0     if RBInfo.perform_nested_POD
        0       nb_test = nb-90
        0       uₕ_test = Matrix(CSV.read(joinpath(RBInfo.paths.FEM_snap_path,
        -       "uₕ_test.csv"), DataFrame))[:,(nb_test-1)*RBVars.Nₜ+1:nb_test*RBVars.Nₜ]
        -     else
      192       uₕ_test = Matrix(CSV.read(joinpath(RBInfo.paths.FEM_snap_path, "uₕ.csv"),
        -       DataFrame))[:,(nb-1)*RBVars.Nₜ+1:nb*RBVars.Nₜ]
        -     end
        - 
        0     solve_RB_system(RBInfo, RBVars, Param)
        0     reconstruction_time = @elapsed begin
        -       reconstruct_FEM_solution(RBVars)
        -     end
        -     if i_nb > 1
        -       mean_online_time = online_time/(length(param_nbs)-1)
        -       mean_reconstruction_time = reconstruction_time/(length(param_nbs)-1)
        -     end
        - 
       32     H1_err_nb, H1_L2_err_nb = compute_errors(uₕ_test, RBVars, RBVars.S.Xᵘ₀)
        0     H1_L2_err[i_nb] = H1_L2_err_nb
        0     mean_H1_err += H1_err_nb / length(param_nbs)
        0     mean_H1_L2_err += H1_L2_err_nb / length(param_nbs)
        0     mean_pointwise_err += abs.(uₕ_test - RBVars.S.ũ) / length(param_nbs)
        - 
        0     ũ_μ[:, (i_nb-1)*RBVars.Nₜ+1:i_nb*RBVars.Nₜ] = RBVars.S.ũ
        0     uₙ_μ[:, i_nb] = RBVars.S.uₙ
        - 
     3488     @info "Online wall time: $online_time s (snapshot number $nb)"
     3520     @info "Relative reconstruction H1-L2 error: $H1_L2_err_nb (snapshot number $nb)"
        -   end
      288   return (ũ_μ,uₙ_μ,mean_pointwise_err,mean_H1_err,mean_H1_L2_err,H1_L2_err,
        -   mean_online_time,mean_reconstruction_time)
        - end
        - 
        - function online_phase(
        -   RBInfo::Info,
        -   RBVars::PoissonUnsteady,
        -   μ::Matrix,
        -   param_nbs)
        - 
        0   get_norm_matrix(RBInfo, RBVars.S)
       16   (ũ_μ,uₙ_μ,mean_pointwise_err,mean_H1_err,mean_H1_L2_err,H1_L2_err,
        -     mean_online_time,mean_reconstruction_time) =
        -     loop_on_params(RBInfo, RBVars, μ, param_nbs)
        - 
        -   adaptive_loop = false
        -   if adaptive_loop
        -     (ũ_μ,uₙ_μ,mean_pointwise_err,mean_H1_err,mean_H1_L2_err,H1_L2_err,
        -       mean_online_time,mean_reconstruction_time) =
        -       adaptive_loop_on_params(RBInfo,RBVars,mean_pointwise_err)
        -   end
        - 
        -   string_param_nbs = "Params"
        0   for Param_nb in param_nbs
      160     string_param_nbs *= "_" * string(Param_nb)
        -   end
      192   path_μ = joinpath(RBInfo.paths.results_path, string_param_nbs)
        - 
        0   if RBInfo.save_results
     2720     @info "Saving the results..."
      224     create_dir(path_μ)
      208     save_CSV(ũ_μ, joinpath(path_μ, "ũ.csv"))
      208     save_CSV(uₙ_μ, joinpath(path_μ, "uₙ.csv"))
      240     save_CSV(mean_pointwise_err, joinpath(path_μ, "mean_point_err.csv"))
      208     save_CSV(mean_H1_err, joinpath(path_μ, "H1_err.csv"))
      272     save_CSV([mean_H1_L2_err], joinpath(path_μ, "H1L2_err.csv"))
        - 
        0     if !RBInfo.import_offline_structures
        0       times = Dict(RBVars.S.offline_time=>"off_time",
        -         mean_online_time=>"on_time", mean_reconstruction_time=>"rec_time")
        -     else
        0       times = Dict(mean_online_time=>"on_time",
        -         mean_reconstruction_time=>"rec_time")
        -     end
      208     CSV.write(joinpath(path_μ, "times.csv"),times)
        -   end
        - 
      672   pass_to_pp = Dict("path_μ"=>path_μ,
        -     "FEMSpace"=>FEMSpace, "H1_L2_err"=>H1_L2_err,
        -     "mean_H1_err"=>mean_H1_err, "mean_point_err_u"=>mean_pointwise_err)
        - 
        0   if RBInfo.postprocess
        0     @info "Post-processing the results..."
        0     post_process(RBInfo, pass_to_pp)
        -   end
        - 
        -   #=
        -   plot_stability_constant(FEMSpace,RBInfo,Param,Nₜ)
        -   =#
        - 
        - end
        - 
        - function post_process(RBInfo::UnsteadyInfo, d::Dict)
        -   if isfile(joinpath(RBInfo.paths.ROM_structures_path, "MDEIM_Σ.csv"))
        -     MDEIM_Σ = load_CSV(joinpath(RBInfo.paths.ROM_structures_path, "MDEIM_Σ.csv"))
        -     generate_and_save_plot(
        -       eachindex(MDEIM_Σ), MDEIM_Σ, "Decay singular values, MDEIM",
        -       ["σ"], "σ index", "σ value", RBInfo.paths.results_path; var="MDEIM_Σ")
        -   end
        -   if isfile(joinpath(RBInfo.paths.ROM_structures_path, "DEIM_Σ.csv"))
        -     DEIM_Σ = load_CSV(joinpath(RBInfo.paths.ROM_structures_path, "DEIM_Σ.csv"))
        -     generate_and_save_plot(
        -       eachindex(DEIM_Σ), DEIM_Σ, "Decay singular values, DEIM",
        -       ["σ"], "σ index", "σ value", RBInfo.paths.results_path; var="DEIM_Σ")
        -   end
        - 
        -   times = collect(RBInfo.t₀+RBInfo.δt:RBInfo.δt:RBInfo.T)
        -   FEMSpace = d["FEMSpace"]
        -   vtk_dir = joinpath(d["path_μ"], "vtk_folder")
        - 
        -   create_dir(vtk_dir)
        -   createpvd(joinpath(vtk_dir,"mean_point_err_u")) do pvd
        -     for (i,t) in enumerate(times)
        -       errₕt = FEFunction(FEMSpace.V(t), d["mean_point_err_u"][:,i])
        -       pvd[i] = createvtk(FEMSpace.Ω, joinpath(vtk_dir,
        -         "mean_point_err_$i" * ".vtu"), cellfields = ["point_err" => errₕt])
        -     end
        -   end
        - 
        -   generate_and_save_plot(times,d["mean_H1_err"],
        -     "Average ||uₕ(t) - ũ(t)||ₕ₁", ["H¹ err"], "time [s]", "H¹ error", d["path_μ"];
        -     var="H1_err")
        -   xvec = collect(eachindex(d["H1_L2_err"]))
        -   generate_and_save_plot(xvec,d["H1_L2_err"],
        -     "||uₕ - ũ||ₕ₁₋ₗ₂", ["H¹-l² err"], "Param μ number", "H¹-l² error", d["path_μ"];
        -     var="H1_L2_err")
        - 
        -   if length(keys(d)) == 8
        - 
        -     createpvd(joinpath(vtk_dir,"mean_point_err_p")) do pvd
        -       for (i,t) in enumerate(times)
        -         errₕt = FEFunction(FEMSpace.Q, d["mean_point_err_p"][:,i])
        -         pvd[i] = createvtk(FEMSpace.Ω, joinpath(vtk_dir,
        -           "mean_point_err_$i" * ".vtu"), cellfields = ["point_err" => errₕt])
        -       end
        -     end
        - 
        -     generate_and_save_plot(times,d["mean_L2_err"],
        -       "Average ||pₕ(t) - p̃(t)||ₗ₂", ["l² err"], "time [s]", "L² error", d["path_μ"];
        -       var="L2_err")
        -     xvec = collect(eachindex(d["L2_L2_err"]))
        -     generate_and_save_plot(xvec,d["L2_L2_err"],
        -       "||pₕ - p̃||ₗ₂₋ₗ₂", ["l²-l² err"], "Param μ number", "L²-L² error", d["path_μ"];
        -       var="L2_L2_err")
        - 
        -   end
        - 
        - end
        - 
        - function plot_stability_constants(
        -   FEMSpace::FEMProblem,
        -   RBInfo::Info,
        -   Param::ParametricInfoUnsteady)
        - 
        -   M = assemble_mass(FEMSpace, RBInfo, Param)(0.0)
        -   A = assemble_stiffness(FEMSpace, RBInfo, Param)(0.0)
        -   stability_constants = []
        -   for Nₜ = 10:10:1000
        -     const_Nₜ = compute_stability_constant(RBInfo,Nₜ,M,A)
        -     append!(stability_constants, const_Nₜ)
        -   end
        -   p = Plot.plot(collect(10:10:1000),
        -     stability_constants, xaxis=:log, yaxis=:log, lw = 3,
        -     label="||(Aˢᵗ)⁻¹||₂", title = "Euclidean norm of (Aˢᵗ)⁻¹", legend=:topleft)
        -   p = Plot.plot!(collect(10:10:1000), collect(10:10:1000),
        -     xaxis=:log, yaxis=:log, lw = 3, label="Nₜ")
        -   xlabel!("Nₜ")
        -   savefig(p, joinpath(RBInfo.paths.results_path, "stability_constant.eps"))
        - 
        -   function compute_stability_constant(RBInfo,Nₜ,M,A)
        -     δt = RBInfo.T/Nₜ
        -     B₁ = RBInfo.θ*(M + RBInfo.θ*δt*A)
        -     B₂ = RBInfo.θ*(-M + (1-RBInfo.θ)*δt*A)
        -     λ₁,_ = eigs(B₁)
        -     λ₂,_ = eigs(B₂)
        -     return 1/(minimum(abs.(λ₁)) + minimum(abs.(λ₂)))
        -   end
        - 
        - end
