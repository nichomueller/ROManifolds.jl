        - function FEM_paths(root, problem_type, problem_name, mesh_name, case; test_case="")
        - 
      448   @assert isdir(root) "$root is an invalid root directory"
        - 
      192   root_tests = joinpath(root, "tests")
      448   create_dir(root_tests)
      448   mesh_path = joinpath(root_tests, joinpath("meshes", mesh_name))
      448   @assert isfile(mesh_path) "$mesh_path is an invalid mesh path"
      192   type_path = joinpath(root_tests, problem_type)
      448   create_dir(type_path)
      224   problem_path = joinpath(type_path, problem_name)
      448   create_dir(problem_path)
      480   problem_and_info_path = joinpath(problem_path, "case" * string(case))
      448   create_dir(problem_and_info_path)
      288   current_test = joinpath(problem_and_info_path, mesh_name)
      448   create_dir(current_test)
      288   FEM_path = joinpath(current_test, "FEM_data")
      448   create_dir(FEM_path)
      384   FEM_snap_path = joinpath(FEM_path, "snapshots"*test_case)
      448   create_dir(FEM_snap_path)
      320   FEM_structures_path = joinpath(FEM_path, "FEM_structures")
      448   create_dir(FEM_structures_path)
        - 
        0   _ -> (mesh_path, current_test, FEM_snap_path, FEM_structures_path)
        - 
        - end
        - 
        - function get_ParamInfo(::NTuple{1,Int},Info::SteadyInfo,μ::Vector)
        - 
        -   model = DiscreteModelFromFile(Info.paths.mesh_path)
        - 
        -   function prepare_α(x, μ, probl_nl)
        -     if !probl_nl["A"]
        -       return sum(μ)
        -     else
        -       return 1 + μ[3] + 1 / μ[3] * exp(-((x[1] - μ[1])^2 + (x[2] - μ[2])^2) / μ[3])
        -     end
        -   end
        -   α(x) = prepare_α(x, μ, Info.probl_nl)
        - 
        -   function prepare_f(x, μ, probl_nl)
        -     if probl_nl["f"]
        -       return sin(μ[4] * x[1]) + sin(μ[4] * x[2])
        -     else
        -       return 1
        -     end
        -   end
        -   f(x) = prepare_f(x, μ, Info.probl_nl)
        -   g(x) = 0
        -   h(x) = 1
        - 
        -   ParametricInfo(μ, model, α, f, g, h)
        - 
        - end
        - 
        - function get_ParamInfo(::NTuple{1,Int},Info::UnsteadyInfo,μ::Vector)
        - 
     1680   model = DiscreteModelFromFile(Info.paths.mesh_path)
        0   αₛ(x) = 1
        0   αₜ(t, μ) = sum(μ) * (2 + sin(2π * t))
        0   mₛ(x) = 1
        0   mₜ(t::Real) = 1
      336   m(x, t::Real) = mₛ(x)*mₜ(t)
        -   m(t::Real) = x -> m(x, t)
        0   fₛ(x) = 1
        0   fₜ(t::Real) = sin(π * t)
        0   gₛ(x) = 0
        0   gₜ(t::Real) = 0
      336   g(x, t::Real) = gₛ(x)*gₜ(t)
        -   g(t::Real) = x -> g(x, t)
        0   hₛ(x) = 0
        0   hₜ(t::Real) = 0
      336   h(x, t::Real) = hₛ(x)*hₜ(t)
        -   h(t::Real) = x -> h(x, t)
        0   u₀(x) = 0
        - 
        0   function prepare_α(x, t, μ, probl_nl)
        0     if !probl_nl["A"]
        0       return αₛ(x)*αₜ(t, μ)
        -     else
        0       return (10 + μ[3] + 1 / μ[3] * exp(-((x[1] - μ[1])^2 + (x[2] - μ[2])^2) * sin(t) / μ[3]))
        -     end
        -   end
170288448   α(x, t::Real) = prepare_α(x, t, μ, Info.probl_nl)
  6444752   α(t::Real) = x -> α(x, t)
        - 
        0   function prepare_f(x, t, μ, probl_nl)
        0     if !probl_nl["f"]
        0       return fₛ(x)*fₜ(t)
        -     else
        0       return 10+5*sin(π*t*sum(x)*(μ[4]+μ[5]))
        -     end
        -   end
2253094800   f(x, t::Real) = prepare_f(x, t, μ, Info.probl_nl)
205091152   f(t::Real) = x -> f(x, t)
        - 
        0   ParametricInfoUnsteady(
        -     μ, model, αₛ, αₜ, α, mₛ, mₜ, m, fₛ, fₜ, f, g, hₛ, hₜ, h, u₀)
        - 
        - end
        - 
        - function get_ParamInfo(::NTuple{2,Int},Info::UnsteadyInfo,μ::Vector)
        - 
        0   model = DiscreteModelFromFile(Info.paths.mesh_path)
        0   αₛ(x) = 1
        0   αₜ(t::Real, μ) = sum(μ) * (2 + sin(2π * t))
        0   mₛ(x) = 1
        0   mₜ(t::Real) = 1
        0   m(x, t::Real) = mₛ(x)*mₜ(t)
        -   m(t::Real) = x -> m(x, t)
        0   fₛ(x) = VectorValue(0.,0.,0.)
        0   fₜ(t::Real) = 0
        0   f(x, t::Real) = fₛ(x)*fₜ(t)
        -   f(t::Real) = x -> f(x, t)
        0   gʷ(x, t::Real) = VectorValue(0.,0.,0.)
        -   gʷ(t::Real) = x -> gʷ(x, t)
        -   x0 = Point(0.,0.,0.)
        -   R = 1
        0   gₛ(x) = 2 * (1 .- VectorValue((x[1]-x0[1])^2,(x[2]-x0[2])^2,(x[3]-x0[3])^2) / R^2) / (pi*R^2)
        0   gₜ(t::Real, μ) = 1-cos(2*pi*t/T)+μ[2]*sin(2*pi*μ[1]*t/T)
        0   gⁱⁿ(x, t::Real) = gₛ(x)*gₜ(t, μ)
        -   gⁱⁿ(t::Real) = x -> gⁱⁿ(x, t)
        0   hₛ(x) = VectorValue(0.,0.,0.)
        0   hₜ(t::Real) = 0
        0   h(x, t::Real) = hₛ(x)*hₜ(t)
        -   h(t::Real) = x -> h(x, t)
        0   u₀(x) = VectorValue(0.,0.,0.)
        0   p₀(x) = 0.
        0   function x₀(x)
        -     return [u₀(x), p₀(x)]
        -   end
        - 
        0   function prepare_α(x, t, μ, probl_nl)
        -     if !probl_nl["A"]
        -       return αₛ(x)*αₜ(t, μ)
        -     else
        -       return (1 + μ[3] + 1 / μ[3] * exp(-((x[1] - μ[1])^2 + (x[2] - μ[2])^2) * sin(t) / μ[3]))
        -     end
        -   end
        0   α(x, t::Real) = prepare_α(x, t, μ, Info.probl_nl)
        -   α(t::Real) = x -> α(x, t)
        - 
        -   function prepare_g(x, t, μ, case)
        -     if case <= 1
        -       gⁱⁿ(x, t::Real) = gₛ(x)*gₜ(t, μ)
        -       gⁱⁿ(t::Real) = x -> gⁱⁿ(x, t)
        -       return gⁱⁿ#[gʷ,gⁱⁿ]
        -     else
        -       gⁱⁿ₁(x, t::Real) = gₛ(x)*gₜ(t, μ[end-2:end-1])*μ[end]
        -       gⁱⁿ₁(t::Real) = x -> g(x, t)
        -       gⁱⁿ₂(x, t::Real) = gₛ(x)*(1-gₜ(t, μ[end-2:end-1])*μ[end])
        -       gⁱⁿ₂(t::Real) = x -> g(x, t)
        -       return gⁱⁿ₁#[gʷ,gⁱⁿ₁,gⁱⁿ₂]
        -     end
        -   end
        -   #g(x, t::Real) = prepare_g(x, t, μ, Info.case)
        0   g(x, t::Real) = gₛ(x)*gₜ(t, μ)
        -   g(t::Real) = x -> g(x, t)
        - 
        0   ParametricInfoUnsteady(
        -     μ, model, αₛ, αₜ, α, mₛ, mₜ, m, fₛ, fₜ, f, g, hₛ, hₜ, h, x₀)
        - 
        - end
        - 
        - function generate_vtk_file(FEMSpace::FEMProblem, path::String, var_name::String, var::Array)
        - 
        -   FE_var = FEFunction(FEMSpace.V, var)
        -   writevtk(FEMSpace.Ω, path, cellfields = [var_name => FE_var])
        - 
        - end
        - 
        - function find_FE_elements(V₀::UnconstrainedFESpace, trian::Triangulation, idx::Vector)
        - 
        0   connectivity = get_cell_dof_ids(V₀, trian)
        - 
       64   el = Int64[]
        0   for i = 1:length(idx)
  6473088     for j = 1:size(connectivity)[1]
  3455984       if idx[i] in abs.(connectivity[j])
  6911136         append!(el, j)
        -       end
        -     end
        -   end
        - 
        0   unique(el)
        - 
        - end
        - 
        - function generate_dcube_discrete_model(I::Info,d::Int64,npart::Int,mesh_name::String)
        - 
        -   if !occursin(".json",mesh_name)
        -     mesh_name *= ".json"
        -   end
        -   mesh_dir = I.paths.mesh_path[1:findall(x->x=='/',I.paths.mesh_path)[end]]
        -   mesh_path = joinpath(mesh_dir,mesh_name)
        -   generate_dcube_discrete_model(d,npart,mesh_path)
        - 
        - end
        - 
        - function generate_dcube_discrete_model(d::Int,npart::Int,path::String)
        -   @assert d ≤ 3 "Select d-dimensional domain, where d ≤ 3"
        -   if d == 1
        -     domain = (0,1)
        -     partition = (npart)
        -   elseif d == 2
        -     domain = (0,1,0,1)
        -     partition = (npart,npart)
        -   else
        -     domain = (0,1,0,1,0,1)
        -     partition = (npart,npart,npart)
        -   end
        -   model = CartesianDiscreteModel(domain,partition)
        -   to_json_file(model,path)
        - end
